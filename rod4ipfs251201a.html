<!doctype html>
<html>
<head><title>RockoperaDesign</title></head>

<body style="background-color:#1B1B1B; color:#C1B7A0; font-family: sans-serif">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.css"/>
<script src="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.js"></script>
    <script>
        Coloris({
            theme: 'polaroid',
            themeMode: 'dark',
            alpha: false,
            onChange: (color, inputEl) => {
                console.log(`The new color is ${color}`);
            }
        });
    </script>
    
    <div style="text-align:right">
        <span id="greetingSpan">Hello, whoever you are.</span>
        <button id="connectButton">Connect Metamask wallet!</button>
    </div>
    
    <center>
    
    <H1 style="font-family: serif">RockoperaDesign</H1>
    Own a design. Name that design. Make art onchain.<BR>
    <a href="https://opensea.io/collection/rockoperadesign" style="color:#C1B7A0;">collection @ OpenSea</a>,
    <a href="https://github.com/mlamont/cherrypit" style="color:#C1B7A0;">front-end code @ Github</a>, 
    <a href="https://github.com/mlamont/rockoperadesign" style="color:#C1B7A0;">back-end code @ Github</a>, 
    <a href="https://etherscan.io/address/0x4Ca3b723F6c08B18892A9b1e34872Bc10c65c3d0" style="color:#C1B7A0;">contract @ Etherscan</a><BR><BR>

    <H2 style="font-family: serif">Design a 4x4 square.</H2>
    <input type="checkbox" id="square00"><input type="checkbox" id="square01"><input type="checkbox" id="square02"><input type="checkbox" id="square03"><BR>
    <input type="checkbox" id="square04"><input type="checkbox" id="square05"><input type="checkbox" id="square06"><input type="checkbox" id="square07"><BR>
    <input type="checkbox" id="square08"><input type="checkbox" id="square09"><input type="checkbox" id="square10"><input type="checkbox" id="square11"><BR>
    <input type="checkbox" id="square12"><input type="checkbox" id="square13"><input type="checkbox" id="square14"><input type="checkbox" id="square15"><BR>
    <!--<input type="text" id="tokenCodeInput" placeholder="xoxoxxooooxxoxox"/>-->
    
    
    <H2 style="font-family: serif">Is it named?</H2>
    <button id="namedButton">Get info!</button><BR><BR>
    current name: <span id="currentNameSpan"></span><BR>
    current owner: <span id="currentOwnerSpan"></span><BR>

    <!-- #_0 -->
    <div id="ownerIsNobodyDiv" hidden>
    <H2 style="font-family: serif">Ooh! Want this?</H2>
    <label for="nameInput">Pick a name: </label>
    <input id="nameInput" />
    <button id="nameItButton">Name it! (fee + gas)</button><BR>
    Fee is 10 ETH for: all selected, all unselected<BR>
    Fee is 0.001 ETH for: every other design<BR>
    When done, wait a sec, then check out the NFT in your wallet.
    </div>

    <!-- #_8 -->
    <div id="poorDiv" hidden>
    <H2 style="font-family: serif">Need more funds.</H2>
    Get more ETH in your wallet.<BR>
    Then click that 'Get info!' button again to continue.<BR>
    </div>

    <!-- #_9 -->
    <div id="ownerIsSomebodyDiv" hidden>
    <H2 style="font-family: serif">Connect Metamask wallet.</H2>
    Then click that 'Get info!' button again to continue.<BR>
    </div>

    <!-- #_2 -->
    <div id="ownerIsNotMeDiv" hidden>
    <H2 style="font-family: serif">Dang! It's taken.</H2>
    Oh well... design another 4x4 square.
    </div>

    <!-- #_1 -->
    <div id="ownerIsMeDiv" hidden>
    <H2 style="font-family: serif">Yep! It's yours.</H2>
    <label for="renameInput">Pick a name: </label>
    <input id="renameInput" />
    <button id="renameItButton">Rename it! (just pay gas)</button><BR>
    When done, wait a sec, then refresh the NFT's metadata to see the new name.
    </div>

    </center>
<BR><BR><HR>
    <div style="text-align:center">
      <!--
        <H2 style="font-family: serif">About Naming Design</H2>
        Imagine yourself in a hardware store. In the back.<BR>
        Look at that wall of cards with the colors on them.<BR>
        All those colors have names.<BR>
        What committee got together to decide on the names of those colors?<BR>
        For ALL those colors!<BR>
        Look, I'm sorry, but some of those names are pretty silly.<BR>
        (Except "firetruck red". They weren't kidding.)<BR>
        I believe... you & I can do better.<BR>
        More creative names, or at least less boring ones.<BR>
        More culturally diverse names, or at least ones in different languages.<BR>
        More meaningful names, or at least ones with an interesting story.<BR>
        So that's what this Rockopera Color project lets you do.<BR><BR>
        <b>Collect 1 NFT color swatch for each of the over 16 million web colors.</b><BR><BR>
        And maybe have some fun along the way.<BR>
        <BR>
        <H2 style="font-family: serif">About Owning Design</H2>
        Imagine owning a color. Let's say it's that "firetruck red".<BR>
        You own it. Congrats. It's yours now.<BR>
        Do you know what this means?<BR>
        Neither do I.<BR>
        It doesn't feel right to own something available to all of us.<BR>
        It doesn't make sense to own something intangible.<BR>
        It doesn't seem remotely similar to owning other things.<BR>
        Yet that's why I'm drawn to this project.<BR><BR>
        <b>By tokenizing color, I'm making something intangible, tangible.</b><BR><BR>
        And now we enable something new.<BR>
        <BR>
        <H2 style="font-family: serif">About Onchain Art</H2>
        Imagine you're about to sign an important document.<BR>
        What color is the ink of the pen in your hand?<BR>
        I bet it's either blue or black.<BR>
        Like I know I've been told are the only acceptable colors.<BR>
        For signing checks at a bank.<BR>
        But what if you could sign it in YOUR "firetruck red"?<BR>
        Then all the peoples would know that that signature was definitely yours.<BR>
        Because ONLY YOU have that color.<BR>
        That color just became your signature color.<BR>
        (Pun intended.)<BR>
        Now... let's be real.<BR>
        Nobody's stopping other "firetruck red" pens from being made.<BR>
        Nobody's preventing your pen from being stolen.<BR>
        Nobody's saying you couldn't accidentally lose your pen.<BR>
        Now... let's be Web3.<BR>
        Nobody could duplicate the token, depending on the contract's type.<BR>
        Nobody could steal the token, depending on the contract's security.<BR>
        Nobody could lose the token, depending on the owner's onchain practices.<BR>
        Sure, we'd need dApps that would only accept this specific source of color.<BR>
        From a set of sources of artistic building blocks.<BR>
        So that's what I'm building. (Incrementally.)<BR>
        And releasing along the way. (Iteratively.)<BR>
        Even if it's ugly like this page. (Transparently.)<BR><BR>
        <b>To make more onchain art work, we need more onchain art tech.</b><BR><BR>
        And thus this lowers the barrier for each of us.<BR>
        For you.<BR>
        To create and share, and now own, your rockopera.<BR>
        -->
        <BR>
        <a href="http://design.rockopera.eth.link" style="color:#C1B7A0;">RockoperaDesign</a>, version 2.1.251201a, by <a href="http://rockopera.eth.link/" style="color:#C1B7A0;">Rockopera.eth</a>
    </div>

<!-- 
<script src="./bcn-index.js" type="module"></script>

when folding in all the javascript to this one HTML file
 remember to include, and mod, the constants file
-->
<script type="module">
export const contractAddress = "0x4Ca3b723F6c08B18892A9b1e34872Bc10c65c3d0";
export const abi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error",
  },
  {
    inputs: [
      { internalType: "address", name: "implementation", type: "address" },
    ],
    name: "ERC1967InvalidImplementation",
    type: "error",
  },
  { inputs: [], name: "ERC1967NonPayable", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "address", name: "owner", type: "address" },
    ],
    name: "ERC721IncorrectOwner",
    type: "error",
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
    ],
    name: "ERC721InsufficientApproval",
    type: "error",
  },
  {
    inputs: [{ internalType: "address", name: "approver", type: "address" }],
    name: "ERC721InvalidApprover",
    type: "error",
  },
  {
    inputs: [{ internalType: "address", name: "operator", type: "address" }],
    name: "ERC721InvalidOperator",
    type: "error",
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "ERC721InvalidOwner",
    type: "error",
  },
  {
    inputs: [{ internalType: "address", name: "receiver", type: "address" }],
    name: "ERC721InvalidReceiver",
    type: "error",
  },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "ERC721InvalidSender",
    type: "error",
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "ERC721NonexistentToken",
    type: "error",
  },
  { inputs: [], name: "FailedCall", type: "error" },
  { inputs: [], name: "InvalidDesignxo", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "InvalidTokenId", type: "error" },
  { inputs: [], name: "InvalidTokenName", type: "error" },
  {
    inputs: [{ internalType: "uint256", name: "mintPrice", type: "uint256" }],
    name: "NeedMoreFundsForThisToken",
    type: "error",
  },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "NotTokenOwner", type: "error" },
  { inputs: [], name: "NothingToWithdraw", type: "error" },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "OwnableInvalidOwner",
    type: "error",
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "OwnableUnauthorizedAccount",
    type: "error",
  },
  { inputs: [], name: "ProxyContractCannotBeTokenOwner", type: "error" },
  { inputs: [], name: "UUPSUnauthorizedCallContext", type: "error" },
  {
    inputs: [{ internalType: "bytes32", name: "slot", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error",
  },
  { inputs: [], name: "WithdrawalFailed", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address",
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address",
      },
      { indexed: false, internalType: "bool", name: "approved", type: "bool" },
    ],
    name: "ApprovalForAll",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64",
      },
    ],
    name: "Initialized",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "LogDepositReceived",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "oldTokenName",
        type: "string",
      },
      {
        indexed: true,
        internalType: "string",
        name: "newTokenName",
        type: "string",
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "TokenRename",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "upgradeabilityEnder",
        type: "address",
      },
    ],
    name: "UpgradeabilityEnded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address",
      },
    ],
    name: "Upgraded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "Withdrew",
    type: "event",
  },
  { stateMutability: "payable", type: "fallback" },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "string", name: "designxo", type: "string" }],
    name: "aGetId",
    outputs: [{ internalType: "uint256", name: "n", type: "uint256" }],
    stateMutability: "pure",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "endUpgradeability",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "getApproved",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint256", name: "n", type: "uint256" }],
    name: "getDesignxo",
    outputs: [{ internalType: "string", name: "designxo", type: "string" }],
    stateMutability: "pure",
    type: "function",
  },
  {
    inputs: [{ internalType: "string", name: "designxo", type: "string" }],
    name: "getTokenName",
    outputs: [{ internalType: "string", name: "tokenName", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "string", name: "designxo", type: "string" }],
    name: "getTokenOwner",
    outputs: [{ internalType: "address", name: "tokenOwner", type: "address" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "initialOwner", type: "address" },
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "operator", type: "address" },
    ],
    name: "isApprovedForAll",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "string", name: "designxo", type: "string" },
      { internalType: "string", name: "newTokenName", type: "string" },
    ],
    name: "modTokenName",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "string", name: "designxo", type: "string" },
      { internalType: "address", name: "newTokenOwner", type: "address" },
    ],
    name: "modTokenOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "string", name: "designxo", type: "string" }],
    name: "nixToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "ownerOf",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" },
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" },
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "string", name: "designxo", type: "string" },
      { internalType: "string", name: "tokenName", type: "string" },
    ],
    name: "setToken",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "tokenURI",
    outputs: [{ internalType: "string", name: "tokenUri", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      { internalType: "address", name: "newImplementation", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [],
    name: "upgradeabilityEnded",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  { stateMutability: "payable", type: "receive" },
];

import {
  createWalletClient,
  custom,
  createPublicClient,
  http,
  parseEther,
} from "https://esm.sh/viem";
import { mainnet } from "https://esm.sh/viem/chains";

// grab website elements
const greetingSpan = document.getElementById("greetingSpan");
const connectButton = document.getElementById("connectButton");
const tokenCodeInput = document.getElementById("tokenCodeInput");
const namedButton = document.getElementById("namedButton");
const currentNameSpan = document.getElementById("currentNameSpan");
const currentOwnerSpan = document.getElementById("currentOwnerSpan");
const renameInput = document.getElementById("renameInput");
const renameItButton = document.getElementById("renameItButton");
const nameInput = document.getElementById("nameInput");
const nameItButton = document.getElementById("nameItButton");
const ownerIsNobodyDiv = document.getElementById("ownerIsNobodyDiv");
const poorDiv = document.getElementById("poorDiv");
const ownerIsSomebodyDiv = document.getElementById("ownerIsSomebodyDiv");
const ownerIsNotMeDiv = document.getElementById("ownerIsNotMeDiv");
const ownerIsMeDiv = document.getElementById("ownerIsMeDiv");

const s00 = document.getElementById("square00");
const s01 = document.getElementById("square01");
const s02 = document.getElementById("square02");
const s03 = document.getElementById("square03");
const s04 = document.getElementById("square04");
const s05 = document.getElementById("square05");
const s06 = document.getElementById("square06");
const s07 = document.getElementById("square07");
const s08 = document.getElementById("square08");
const s09 = document.getElementById("square09");
const s10 = document.getElementById("square10");
const s11 = document.getElementById("square11");
const s12 = document.getElementById("square12");
const s13 = document.getElementById("square13");
const s14 = document.getElementById("square14");
const s15 = document.getElementById("square15");

// initialize viem pieces
let walletClient;
let publicClient;

let tokenCode;
let tokenId;
let tokenName;
let tokenOwner;
let connectedAccount;
let price;

async function connect() {
  if (typeof window.ethereum !== "undefined") {
    walletClient = createWalletClient({
      chain: mainnet,
      transport: custom(window.ethereum),
    });
    console.log("wallet client created from connect() in bcn-index.js");
    [connectedAccount] = await walletClient.requestAddresses();
    greetingSpan.innerHTML = `Hello, ${connectedAccount}!`;
    connectButton.innerHTML = "(connected)";
  } else {
    connectButton.innerHTML = "(please install Metamask)";
  }
}

async function named() {
  // let's start with a clean UI slate
  renameInput.value = "";
  nameInput.value = "";
  ownerIsNobodyDiv.hidden = true;
  poorDiv.hidden = true;
  ownerIsSomebodyDiv.hidden = true;
  ownerIsNotMeDiv.hidden = true;
  ownerIsMeDiv.hidden = true;
  // ...is Metamask installed...
  if (typeof window.ethereum !== "undefined") {
    // ...Metamask is installed...
    publicClient = createPublicClient({
      chain: mainnet,
      transport: http(),
    });
    console.log("public client created from named() in bcn-index.js");
    // tokenCode = tokenCodeInput.value;

    // let's create that tokenCode from all the checkboxes
    tokenCode = s00.checked ? "x" : "o";
    tokenCode += s01.checked ? "x" : "o";
    tokenCode += s02.checked ? "x" : "o";
    tokenCode += s03.checked ? "x" : "o";
    tokenCode += s04.checked ? "x" : "o";
    tokenCode += s05.checked ? "x" : "o";
    tokenCode += s06.checked ? "x" : "o";
    tokenCode += s07.checked ? "x" : "o";
    tokenCode += s08.checked ? "x" : "o";
    tokenCode += s09.checked ? "x" : "o";
    tokenCode += s10.checked ? "x" : "o";
    tokenCode += s11.checked ? "x" : "o";
    tokenCode += s12.checked ? "x" : "o";
    tokenCode += s13.checked ? "x" : "o";
    tokenCode += s14.checked ? "x" : "o";
    tokenCode += s15.checked ? "x" : "o";

    console.log(tokenCode);
    // let's try to get the token's name & owner
    try {
      tokenName = await publicClient.readContract({
        address: contractAddress,
        abi: abi,
        functionName: "getTokenName",
        args: [tokenCode],
      });
      tokenOwner = await publicClient.readContract({
        address: contractAddress,
        abi: abi,
        functionName: "getTokenOwner",
        args: [tokenCode],
      });
      // ...if we made it this far, inputs were valid, and token exists...
      // let's show the token's name & owner
      currentNameSpan.innerHTML = tokenName;
      currentOwnerSpan.innerHTML = tokenOwner;
      // ...did the user connect...
      if (typeof connectedAccount !== "undefined") {
        // ...user connected... (but could've changed account since)
        // let's get the current connected account
        [connectedAccount] = await walletClient.requestAddresses();
        // ...is the user the owner...
        if (connectedAccount == tokenOwner) {
          // ...user is the owner...
          ownerIsMeDiv.hidden = false; // ...owner exists, and is user
        } else {
          // ...user is not the owner...
          ownerIsNotMeDiv.hidden = false; // ...owner exists, and is not user
        }
      } else {
        // ...user did not connect...
        ownerIsSomebodyDiv.hidden = false; // ...retry, pal
      }
    } catch (error) {
      // ...some kind of error happened from trying to get the token's name & owner...
      console.log(error.message);
      // ...is the error about the token not existing...
      if (error.message.includes("InvalidTokenId")) {
        // ...ah, right, token doesn't exist...
        currentNameSpan.innerHTML = "Up for grabs!";
        currentOwnerSpan.innerHTML = "Could be you!";
        // ...did the user connect...
        if (typeof connectedAccount !== "undefined") {
          // ...user did connect...
          ownerIsNobodyDiv.hidden = false; // ...owner does not exist
        } else {
          // ...user did not connect...
          ownerIsSomebodyDiv.hidden = false; // ...retry, pal
        }
      } else {
        // ...uh, well, it's some other error...
        currentNameSpan.innerHTML = "please try...";
        currentOwnerSpan.innerHTML = "...that again";
      }
    }
  } else {
    // ...Metamask is not installed...
    ownerIsSomebodyDiv.hidden = false; // ...retry, pal
  }
}

async function renameIt() {
  // first: connect! (gets the current connected account)
  connect();
  // now:
  try {
    publicClient = createPublicClient({
      chain: mainnet,
      transport: http(),
    });
    console.log("public client created from renameIt()");
    const { request } = await publicClient.simulateContract({
      account: connectedAccount,
      address: contractAddress,
      abi: abi,
      functionName: "modTokenName",
      args: [tokenCode, renameInput.value],
      chain: mainnet,
    });
    console.log("simulated contract from renameIt()");
    await walletClient.switchChain({ id: 1 });
    const hash = await walletClient.writeContract(request);
    console.log(hash);
  } catch (error) {
    console.log(error);
  }
}

async function nameIt() {
  // first: connect! (gets the current connected account)
  connect();
  // now:
  try {
    publicClient = createPublicClient({
      chain: mainnet,
      transport: http(),
    });
    console.log("public client created from nameIt()");

    // art tech in a codified form:
    // tokenCode = tokenCodeInput.value;
    console.log(tokenCode);

    // art tech in decimal form:
    tokenId = await publicClient.readContract({
      address: contractAddress,
      abi: abi,
      functionName: "aGetId",
      args: [tokenCode],
    });
    console.log("did aGetId()");
    console.log(tokenId);

    // set price:
    price = parseEther("0.001");
    console.log("Price set to 0.001 ETH.");
    if (tokenId == 0 || tokenId == 65535) {
      price = parseEther("10");
      console.log("Price set to 10 ETH!!");
    }
    console.log(price);

    // test run a minting:
    const { request } = await publicClient.simulateContract({
      account: connectedAccount,
      address: contractAddress,
      abi: abi,
      functionName: "setToken",
      args: [tokenCode, nameInput.value],
      value: price,
      chain: mainnet,
    });
    console.log("simulated contract from nameIt()");

    // if that test run works, do the actual mint:
    await walletClient.switchChain({ id: 1 }); // ensure we're on ETH mainnet
    const hash = await walletClient.writeContract(request);
    console.log(hash);
  } catch (error) {
    console.log("Looks like we gots ourselves an error!");
    console.log(error.message);
    currentNameSpan.innerHTML = "please try...";
    currentOwnerSpan.innerHTML = "...that again";

    // ...is the error about insufficient funds...
    if (
      error.message.includes("insufficient") ||
      error.message.includes("NeedMoreFundsForThis")
    ) {
      // ...ah, right, not enough funds...
      poorDiv.hidden = false; // ...get richer, then retry
    }
  }
}

connectButton.onclick = connect;
namedButton.onclick = named;
renameItButton.onclick = renameIt;
nameItButton.onclick = nameIt;


</script>

</body>
</html>